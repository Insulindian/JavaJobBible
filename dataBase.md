# MySql

## MySql的引擎
- MyISAM：默认引擎，支持表级锁，速度快，支持全文索引，但不支持事务和外键约束。
- InnoDB：支持行级锁，支持事务和外键约束，性能较好，但速度比MyISAM慢。

## 为什么使用InnoDB作为默认引擎
- 支持事务：InnoDB支持ACID事务，保证数据的一致性和完整性。
- 支持外键约束：InnoDB支持外键约束，保证数据的完整性和一致性。
- 支持行级锁：InnoDB支持行级锁，避免了表级锁带来的性能问题。
- 支持崩溃恢复：InnoDB支持崩溃恢复，保证数据的安全性。

# MySql 索引

## B+树和B树的区别 为什么innodb使用B+树作为索引结构
- B+树的所有值都在叶子节点上，非叶子节点只存储索引信息，B树的非叶子节点也存储值。
- B+树的叶子节点通过指针双向相连，B树的非叶子节点不相连。
- B+树的查询效率更高，因为所有值都在叶子节点上，非叶子节点只存储索引信息，树更矮,减少了IO操作。
- B+树有大量冗余结点,插入删除效率更高
## 查询到b+树的叶子节点后，如何找到对应的记录
数据页

## 什么情况下索引会失效
1. 使用 `LIKE` 模糊查询时以 `%` 开头
   - 示例：
     ```sql
     SELECT * FROM users WHERE name LIKE '%abc';
     ```
   - 原因：以 `%` 开头会导致无法使用索引，因为无法确定匹配的起始位置。

2. 查询条件中对索引列进行了函数操作
   - 示例：
     ```sql
     SELECT * FROM users WHERE YEAR(birth_date) = 1990;
     ```
   - 原因：对索引列使用函数或表达式会导致索引失效，因为索引存储的是原始值。

3. 查询条件中对索引列进行了隐式类型转换
   - 示例：
     ```sql
     SELECT * FROM users WHERE phone_number = 1234567890;
     ```
   - 原因：如果 `phone_number` 是字符串类型，而查询中传入的是数字，MySQL 会进行隐式类型转换，导致索引失效。

4. 使用 `OR` 条件且不是所有列都有索引
   - 示例：
     ```sql
     SELECT * FROM users WHERE name = 'John' OR age = 30;
     ```
   - 原因：如果 `name` 和 `age` 列中只有一个有索引，索引会失效。

5. 没有遵循最左匹配原则
   - 示例：
     ```sql
     SELECT * FROM users WHERE last_name = 'Smith' AND first_name = 'John';
     ```
   - 原因：如果 `last_name` 是复合索引的第一列，而查询中只使用了第二列，索引会失效。

## 索引优化


# 事务
## 事务的四个特性   
- 原子性（Atomicity）：事务是一个不可分割的操作单元，要么全部成功，要么全部失败。
- 一致性（Consistency）：事务执行前后，数据的一致性必须得到保持。   
- 隔离性（Isolation）：多个事务并发执行时，互不干扰，每个事务的执行结果对其他事务是不可见的。
- 持久性（Durability）：一旦事务提交，对数据库的修改是永久性的，即使系统崩溃也不会丢失。